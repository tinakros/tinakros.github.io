import{_ as s,o as a,c as l,a as n}from"./app.fd321afd.js";const h=JSON.parse('{"title":"React codewhy","description":"","frontmatter":{},"headers":[{"level":2,"title":"开发依赖","slug":"开发依赖","link":"#开发依赖","children":[]},{"level":2,"title":"React特点","slug":"react特点","link":"#react特点","children":[{"level":3,"title":"如何封装一个组件","slug":"如何封装一个组件","link":"#如何封装一个组件","children":[]}]},{"level":2,"title":"初识JSX","slug":"初识jsx","link":"#初识jsx","children":[{"level":3,"title":"什么是JSX","slug":"什么是jsx","link":"#什么是jsx","children":[]},{"level":3,"title":"3.1 JSX的书写规范","slug":"_3-1-jsx的书写规范","link":"#_3-1-jsx的书写规范","children":[]},{"level":3,"title":"this的绑定","slug":"this的绑定","link":"#this的绑定","children":[]},{"level":3,"title":"条件渲染","slug":"条件渲染","link":"#条件渲染","children":[]},{"level":3,"title":"JSX本质","slug":"jsx本质","link":"#jsx本质","children":[]},{"level":3,"title":"虚拟DOM的创建过程","slug":"虚拟dom的创建过程","link":"#虚拟dom的创建过程","children":[]},{"level":3,"title":"虚拟DOM跨平台渲染","slug":"虚拟dom跨平台渲染","link":"#虚拟dom跨平台渲染","children":[]},{"level":3,"title":"声明式编程","slug":"声明式编程","link":"#声明式编程","children":[]},{"level":3,"title":"React 组件化","slug":"react-组件化","link":"#react-组件化","children":[]}]},{"level":2,"title":"类组件","slug":"类组件","link":"#类组件","children":[{"level":3,"title":"render函数返回值","slug":"render函数返回值","link":"#render函数返回值","children":[]}]},{"level":2,"title":"函数组件","slug":"函数组件","link":"#函数组件","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"1.装载Mount","slug":"_1-装载mount","link":"#_1-装载mount","children":[]},{"level":3,"title":"2.更新Update","slug":"_2-更新update","link":"#_2-更新update","children":[]},{"level":3,"title":"3.卸载UnMount","slug":"_3-卸载unmount","link":"#_3-卸载unmount","children":[]}]}],"relativePath":"frontend/react/r3.md","lastUpdated":null}'),e={name:"frontend/react/r3.md"},t=n(`<h1 id="react-codewhy" tabindex="-1">React codewhy <a class="header-anchor" href="#react-codewhy" aria-hidden="true">#</a></h1><h2 id="开发依赖" tabindex="-1">开发依赖 <a class="header-anchor" href="#开发依赖" aria-hidden="true">#</a></h2><blockquote><p>react 包含react所必须的核心代码</p><p>react-dom react渲染在不同平台所需要的核心代码</p><p>babel 将jsx转化为react代码的工具</p></blockquote><h2 id="react特点" tabindex="-1">React特点 <a class="header-anchor" href="#react特点" aria-hidden="true">#</a></h2><ul><li><ol><li>声明式编程</li></ol></li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>特点： 只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面</p></div><p><code>UI = f(state)</code> 数据发生改变的时候 重新执行render函数 重新去渲染页面</p><ul><li><ol start="2"><li>组件化开发</li></ol><ul><li>2.1. 组件化 数据依赖</li><li>2.2. 组件化 事件绑定</li></ul></li></ul><blockquote></blockquote><p>默认情况下，this指向为undefined, react中 是通过JSX编辑，babel编译，最后转化为 js 而babel则开启格模式 因此，默认指向为undefined 在正常DOM操作中，监听函数中的this其实是节点对象 ,react并不是直接渲染真实DOM,我们所编写的button只是语法糖，它的本质React的Element对象；那么在这里发生监听的时候，react在执行函数时并没有绑定this，默况下就是一个undefined</p><p>如果在绑定的函数中，想要使用当前对象 需要拿到this</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">changeText</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bind</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">this</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="如何封装一个组件" tabindex="-1">如何封装一个组件 <a class="header-anchor" href="#如何封装一个组件" aria-hidden="true">#</a></h3><p>定义一个类(类名大写，组件名必须大写) 实现当前组件的render函数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1.定义根组件 </span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">App</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">(){</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">hi world</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h2</span><span style="color:#89DDFF;">&gt;}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//2 渲染根组件  </span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> root </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> ReactDOM</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createRoot</span><span style="color:#A6ACCD;">(document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#root</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">))</span></span>
<span class="line"><span style="color:#A6ACCD;">root</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">App</span><span style="color:#89DDFF;">/&gt;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><ul><li><ol start="3"><li>多平台适配</li></ol></li></ul><p>因为采用了虚拟 DOM（Virtual DOM）技术，这使得 React 可以轻松地在多种平台上渲染 UI 界面，而不需要修改代码。React 把界面抽象成一个个组件，组件可以独立地在不同平台上渲染，只需要实现不同平台的 UI 元素即可。</p><blockquote><p>ReactNative</p><p>ReactVR</p></blockquote><h2 id="初识jsx" tabindex="-1">初识JSX <a class="header-anchor" href="#初识jsx" aria-hidden="true">#</a></h2><h3 id="什么是jsx" tabindex="-1">什么是JSX <a class="header-anchor" href="#什么是jsx" aria-hidden="true">#</a></h3><p>JSX是一种JavaScript的语法扩展 它用于描述我们的UI界面，并且其完成可以和JavaScript融合在一起使用</p><h3 id="_3-1-jsx的书写规范" tabindex="-1">3.1 JSX的书写规范 <a class="header-anchor" href="#_3-1-jsx的书写规范" aria-hidden="true">#</a></h3><ul><li>必须有根元素</li><li>推荐使用()包裹</li><li>单标签/双标签</li></ul><h3 id="this的绑定" tabindex="-1">this的绑定 <a class="header-anchor" href="#this的绑定" aria-hidden="true">#</a></h3><ol><li>默认绑定 独立执行 foo()</li><li>隐式绑定 被一个对象执行 obj.foo() ---&gt; obj</li><li>显式绑定 call/apply/bind foo.call(&#39;aaa&#39;) ---&gt; String(&#39;aaaa&#39;)</li><li>new绑定 new Foo() -&gt; 创建一个新的对象 并且赋值给this</li></ol><h4 id="如何解决" tabindex="-1">如何解决 <a class="header-anchor" href="#如何解决" aria-hidden="true">#</a></h4><p>bind 给btnClick显示绑定this 使用</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* 1.this绑定方式一: bind绑定 */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">btn1Click</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">按钮1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* 2.this绑定方式二: ES6 class fields */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={this.</span><span style="color:#A6ACCD;">btn2Click</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">按钮2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* 3.this绑定方式三: 直接传入一个箭头函数(重要) */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">btn3Click</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">按钮3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">btn3Click</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">按钮3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>事件传递参数</p><p>推荐 箭头函数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={(</span><span style="color:#A6ACCD;font-style:italic;">e</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">btn</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">handClick</span><span style="color:#A6ACCD;">(e</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">kros</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">18</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><h3 id="条件渲染" tabindex="-1">条件渲染 <a class="header-anchor" href="#条件渲染" aria-hidden="true">#</a></h3><p>vue中为v-if v-show<br> react中 所有的条件判断都和普通的js代码一致</p><ol><li>条件判断语句 适合逻辑较多的情</li><li>三元运算符 适合逻辑比较简单</li><li>与运算符&amp;&amp; 适合如果条件成立，渲染一个组件，若不成立，则不渲染</li><li>v-show的效果 控制display是否为none</li></ol><h3 id="jsx本质" tabindex="-1">JSX本质 <a class="header-anchor" href="#jsx本质" aria-hidden="true">#</a></h3><p>jsx 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖 所有的jsx最终都会被转换成<strong>React.createElement的函数调用</strong>。</p><p>createElement需要传递三个参数 type 例如 div|组件名称 config children</p><h3 id="虚拟dom的创建过程" tabindex="-1">虚拟DOM的创建过程 <a class="header-anchor" href="#虚拟dom的创建过程" aria-hidden="true">#</a></h3><p>react利用ReactElement对象组成了一个JS对象树 js对象树 就是 虚拟DOM (Virtual DOM)</p><p>jsx --转化对应的ReactElement函数的调用 形成 reactElement对象 ---&gt; 渲染 最终形成 真实DOM</p><p>vue中 template 解析完后 --&gt; render函数 调用大量的h函数 变成一个一个对象 对象和对象之间的联系最终形成虚拟DOM --&gt; 真实DOM</p><p>从源码来看 vue没有react那么直观 vue底层做了很多的事情 v-for v-if v-model 等等 react直接交给babel去解析 vue则自己解析</p><h3 id="虚拟dom跨平台渲染" tabindex="-1">虚拟DOM跨平台渲染 <a class="header-anchor" href="#虚拟dom跨平台渲染" aria-hidden="true">#</a></h3><h3 id="声明式编程" tabindex="-1">声明式编程 <a class="header-anchor" href="#声明式编程" aria-hidden="true">#</a></h3><p>虚拟DOM帮助我们从命令式编程转到了声明式编程的模式</p><p>UI以以一种理想化或者虚拟化的方式保存在内存中，并且它是一个相对简单的JS对象 我们可以通过ReactDOM.render让虚拟DOM和真实DOM同步起来，这个过程中叫做协调 (Reconciliation)</p><p>虚拟DOM 同步成为 真实DOM的过程</p><p>craco crate-react-app config</p><h3 id="react-组件化" tabindex="-1">React 组件化 <a class="header-anchor" href="#react-组件化" aria-hidden="true">#</a></h3><p>根据组件的定义 函数组件 | 类组件 组件内部是否有状态需要维护 无状态 | 有状态 组件 组件的不同职责 展示型组件(Presentational Component) | 容器型 (Container Component)</p><h2 id="类组件" tabindex="-1">类组件 <a class="header-anchor" href="#类组件" aria-hidden="true">#</a></h2><p>类组件定义的前提</p><blockquote><p>组件名称大写开头</p><p>类组件需要继承React.Component</p><p>类组件必须实现render函数</p></blockquote><p>也可使用es6语法 中的class定义一个组件</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Test</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">React</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">Component</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 这里----初始化值设置  ---&gt;  可选项</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">render</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;">(</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">aaa</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">vvc</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">xxx</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="render函数返回值" tabindex="-1">render函数返回值 <a class="header-anchor" href="#render函数返回值" aria-hidden="true">#</a></h3><p>当其重新渲染之前肯定会先进行一些条件的判断(props state的变化)并返回以下类型之一</p><ul><li>React 元素：</li><li><ol><li>jsx创建</li></ol></li><li><ol start="2"><li>react渲染的DOM节点 | 自定义组件</li></ol></li><li>数组 | fragments 使用render方法可以返回多个元素</li><li>Portals 可以渲染子节点到不同的DOM子树中</li><li>字符串或数值类型 在DOM中会被渲染为文本节点</li><li>布尔类型或null 什么都不渲染</li></ul><h2 id="函数组件" tabindex="-1">函数组件 <a class="header-anchor" href="#函数组件" aria-hidden="true">#</a></h2><p>使用<code>fucntion</code> 进行定义的函数<br> 无状态组件 没有生命周期 但也会被更新并挂载 没有组件实例 所以this不能指向组件实例<br> 类组件通过生命周期等实现的功能 在函数组件内则用其 对应的hooks去实现</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> function App(){</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">helloWorld~ </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  )</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> App</span></span>
<span class="line"></span></code></pre></div><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-hidden="true">#</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>简而言之，和人的生命时间线一致， 合适的阶段做 做合适的事情</p><ul><li>装载Mount</li><li>更新Update</li><li>卸载UnMount</li></ul></div><h3 id="_1-装载mount" tabindex="-1">1.装载Mount <a class="header-anchor" href="#_1-装载mount" aria-hidden="true">#</a></h3><p><img src="https://s2.loli.net/2023/01/30/WsgBRqbHay5mNLp.png" alt="1675067794732.jpg"></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>生命周期函数的介绍</p></div><h4 id="constructor" tabindex="-1">conStructor <a class="header-anchor" href="#constructor" aria-hidden="true">#</a></h4><p>如果不初始化state或不进行方法绑定 则无需为react组件实现构造函数 constructor中 只做2件事情</p><ul><li>通过this.state 赋值 初始化state数据</li><li>事件绑定实例(this)</li></ul><h4 id="componentdidmount" tabindex="-1">componentDidMount <a class="header-anchor" href="#componentdidmount" aria-hidden="true">#</a></h4><p>会在组件挂载后(完成DOM渲染后) 立即调用 该函数中可以执行的操作</p><ul><li><ol><li>发送网络请求</li></ol></li><li><ol start="2"><li>DOM操作 | 在此添加订阅 willUnMount中取消订阅</li></ol></li></ul><h4 id="componentdidupdate" tabindex="-1">componentDidUpdate <a class="header-anchor" href="#componentdidupdate" aria-hidden="true">#</a></h4><p>会在DOM更新后 立即调用 首次渲染不执行</p><h3 id="_2-更新update" tabindex="-1">2.更新Update <a class="header-anchor" href="#_2-更新update" aria-hidden="true">#</a></h3><p><img src="https://s2.loli.net/2023/01/30/qZRzlJCeDx9wiU2.png" alt="1675068854065.jpg"></p><h3 id="_3-卸载unmount" tabindex="-1">3.卸载UnMount <a class="header-anchor" href="#_3-卸载unmount" aria-hidden="true">#</a></h3><p><img src="https://s2.loli.net/2023/01/30/UVlpQxhHMC61qwb.png" alt="1675068908268.jpg"></p>`,78),o=[t];function p(c,r,i,D,d,F){return a(),l("div",null,o)}const C=s(e,[["render",p]]);export{h as __pageData,C as default};
