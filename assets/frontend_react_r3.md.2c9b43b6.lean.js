import{_ as p,o,c as e,d as n,e as s,b as t,w as c,a,r}from"./app.763bd26d.js";const E=JSON.parse('{"title":"React 笔记","description":"","frontmatter":{},"headers":[{"level":2,"title":"开发依赖","slug":"开发依赖","link":"#开发依赖","children":[]},{"level":2,"title":"React特点","slug":"react特点","link":"#react特点","children":[{"level":3,"title":"如何封装一个组件","slug":"如何封装一个组件","link":"#如何封装一个组件","children":[]}]},{"level":2,"title":"初识JSX","slug":"初识jsx","link":"#初识jsx","children":[{"level":3,"title":"什么是JSX","slug":"什么是jsx","link":"#什么是jsx","children":[]},{"level":3,"title":"3.1 JSX的书写规范","slug":"_3-1-jsx的书写规范","link":"#_3-1-jsx的书写规范","children":[]},{"level":3,"title":"this的绑定","slug":"this的绑定","link":"#this的绑定","children":[]},{"level":3,"title":"条件渲染","slug":"条件渲染","link":"#条件渲染","children":[]},{"level":3,"title":"JSX本质","slug":"jsx本质","link":"#jsx本质","children":[]},{"level":3,"title":"虚拟DOM的创建过程","slug":"虚拟dom的创建过程","link":"#虚拟dom的创建过程","children":[]},{"level":3,"title":"虚拟DOM跨平台渲染","slug":"虚拟dom跨平台渲染","link":"#虚拟dom跨平台渲染","children":[]},{"level":3,"title":"声明式编程","slug":"声明式编程","link":"#声明式编程","children":[]},{"level":3,"title":"React 组件化","slug":"react-组件化","link":"#react-组件化","children":[]}]},{"level":2,"title":"类组件","slug":"类组件","link":"#类组件","children":[{"level":3,"title":"render函数返回值","slug":"render函数返回值","link":"#render函数返回值","children":[]}]},{"level":2,"title":"函数组件","slug":"函数组件","link":"#函数组件","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[{"level":3,"title":"1.装载Mount","slug":"_1-装载mount","link":"#_1-装载mount","children":[]},{"level":3,"title":"2.更新Update","slug":"_2-更新update","link":"#_2-更新update","children":[]},{"level":3,"title":"3.卸载UnMount","slug":"_3-卸载unmount","link":"#_3-卸载unmount","children":[]}]},{"level":2,"title":"组件通信","slug":"组件通信","link":"#组件通信","children":[{"level":3,"title":"1.父组件传值给子组件","slug":"_1-父组件传值给子组件","link":"#_1-父组件传值给子组件","children":[]},{"level":3,"title":"2.子组件传值给父组件","slug":"_2-子组件传值给父组件","link":"#_2-子组件传值给父组件","children":[]},{"level":3,"title":"React插槽(slot)","slug":"react插槽-slot","link":"#react插槽-slot","children":[]},{"level":3,"title":"3.context 非父子组件数据共享","slug":"_3-context-非父子组件数据共享","link":"#_3-context-非父子组件数据共享","children":[]},{"level":3,"title":"4.eventBus 非父子组件通信  事件总线","slug":"_4-eventbus-非父子组件通信-事件总线","link":"#_4-eventbus-非父子组件通信-事件总线","children":[]}]},{"level":2,"title":"setState","slug":"setstate","link":"#setstate","children":[]},{"level":2,"title":"React更新过程","slug":"react更新过程","link":"#react更新过程","children":[]},{"level":2,"title":"关于render函数被调用","slug":"关于render函数被调用","link":"#关于render函数被调用","children":[{"level":3,"title":"-------------源码中 关于PureComponent实现过程 ------------------------","slug":"源码中-关于purecomponent实现过程","link":"#源码中-关于purecomponent实现过程","children":[]}]},{"level":2,"title":"Ref使用","slug":"ref使用","link":"#ref使用","children":[]},{"level":2,"title":"受控&&非受控","slug":"受控-非受控","link":"#受控-非受控","children":[]},{"level":2,"title":"高阶组件(函数)","slug":"高阶组件-函数","link":"#高阶组件-函数","children":[{"level":3,"title":"1.什么是HOC ???","slug":"_1-什么是hoc","link":"#_1-什么是hoc","children":[]},{"level":3,"title":"2.使用HOC的原因","slug":"_2-使用hoc的原因","link":"#_2-使用hoc的原因","children":[]},{"level":3,"title":"3. 应用一 props增强","slug":"_3-应用一-props增强","link":"#_3-应用一-props增强","children":[]},{"level":3,"title":"3. 应用二 渲染判断鉴权","slug":"_3-应用二-渲染判断鉴权","link":"#_3-应用二-渲染判断鉴权","children":[]},{"level":3,"title":"3. 应用三 生命劫持","slug":"_3-应用三-生命劫持","link":"#_3-应用三-生命劫持","children":[]}]},{"level":2,"title":"Portals","slug":"portals","link":"#portals","children":[]},{"level":2,"title":"Fragment  && StrictMode","slug":"fragment-strictmode","link":"#fragment-strictmode","children":[{"level":3,"title":"1. Fragment","slug":"_1-fragment","link":"#_1-fragment","children":[]},{"level":3,"title":"2. StrictMode","slug":"_2-strictmode","link":"#_2-strictmode","children":[]}]},{"level":2,"title":"React过渡动画","slug":"react过渡动画","link":"#react过渡动画","children":[]},{"level":2,"title":"React中CSS编写","slug":"react中css编写","link":"#react中css编写","children":[]},{"level":2,"title":"📢 Redux","slug":"📢-redux","link":"#📢-redux","children":[{"level":3,"title":"js纯函数","slug":"js纯函数","link":"#js纯函数","children":[]},{"level":3,"title":"纯函数的作用和优势","slug":"纯函数的作用和优势","link":"#纯函数的作用和优势","children":[]},{"level":3,"title":"Redux的核心","slug":"redux的核心","link":"#redux的核心","children":[]},{"level":3,"title":"Redux的三大原则","slug":"redux的三大原则","link":"#redux的三大原则","children":[]},{"level":3,"title":"---------------------------[redux一键使用 4步骤 ]-------------------------","slug":"redux一键使用-4步骤","link":"#redux一键使用-4步骤","children":[]},{"level":3,"title":"Redux 图解","slug":"redux-图解","link":"#redux-图解","children":[]}]},{"level":2,"title":"📂 React-Redux","slug":"📂-react-redux","link":"#📂-react-redux","children":[{"level":3,"title":"Redux里组件中的异步操作","slug":"redux里组件中的异步操作","link":"#redux里组件中的异步操作","children":[]},{"level":3,"title":"中间件(Middleware)","slug":"中间件-middleware","link":"#中间件-middleware","children":[]},{"level":3,"title":"redux-thunk","slug":"redux-thunk","link":"#redux-thunk","children":[]}]},{"level":2,"title":"📍 ReduxToolkit","slug":"📍-reduxtoolkit","link":"#📍-reduxtoolkit","children":[]}],"relativePath":"frontend/react/r3.md","lastUpdated":1681727835000}'),F={name:"frontend/react/r3.md"},D=a("",117),y=n("strong",null,"isBatchingUpdates",-1),C=a("",216);function A(i,d,u,h,f,g){const l=r("font");return o(),e("div",null,[D,n("p",null,[s("React中 没有像vue一样 通过数据劫持 Object.defineProperty (getter, setter)等来监听数据的变化 必须通过setState来告知React数据已经发生了变化 从源码中可知 setState是从Component中继承过来的 ，也可通过 "),t(l,{color:"red"},{default:c(()=>[y]),_:1}),s("来判断 setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。一般认为，做异步设计是为了性能优化、减少渲染次数。 一般会被追问（也可以自己说）：在什么情况下 isBatchingUpdates 会为 true 呢？")]),C])}const b=p(F,[["render",A]]);export{E as __pageData,b as default};
